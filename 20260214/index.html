<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‡´æˆ‘æœ€çˆ±çš„ä½  â¤ï¸</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "Microsoft YaHei", sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; touch-action: none; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ff69b4;
            transition: opacity 1s;
        }
        #start-btn {
            display: none; padding: 15px 40px; background: #ff69b4; color: white;
            border: none; border-radius: 30px; font-size: 18px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 20px rgba(255,105,180,0.5);
        }
        #hint {
            position: absolute; bottom: 12%; width: 100%; text-align: center; color: rgba(255,255,255,0.7);
            font-size: 15px; pointer-events: none; opacity: 0; transition: opacity 1.5s;
            text-shadow: 0 0 8px #ff69b4; letter-spacing: 2px;
        }
    </style>
</head>
<body>

<div id="overlay">
    <div style="font-size:50px; margin-bottom: 20px;">ğŸ’–</div>
    <div id="status">è¿˜è¦ä¸€ä¼šæ‰èƒ½èµ°è¿›æˆ‘çš„å¿ƒ...</div>
    <button id="start-btn">å¼€å¯æµªæ¼«æ—¶åˆ»</button>
</div>

<div id="container">
    <div id="hint">âœ¨ é•¿æŒ‰å±å¹•å¹¶æ‹–åŠ¨ï¼Œå¬å¬æˆ‘çš„å¿ƒ âœ¨</div>
</div>
<audio id="bgm" loop src="love.mp3"></audio>

<canvas id="textCanvas" style="display:none;"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>

<script>
    const PHOTO_COUNT = 30;
    const PARTICLE_COUNT = 15000;
    let scene, camera, renderer, starPoints, photoMeshes = [];
    let loadProgress = 0, isTouching = false;
    // tX, tY ç”¨äºç…§ç‰‡ä¸­å¿ƒï¼›dragOffset ç”¨äºæ–‡å­—æ‹–æ‹½åç§»
    let tX = 0, tY = 0, dragStartX = 0, dragStartY = 0, dragOffsetX = 0, dragOffsetY = 0;

    let heartPositions = [];
    let textOptionsPositions = [];
    let particleAttributes = [], photoRandoms = [];
    let currentTextIndex = 0;

    // ç²¾ç®€åçš„è¯­å½•åº“ (13å¥)
    const loveWords = [
        "æˆ‘åªçˆ±ç”°ç”œ", "æˆ‘å¥½æƒ³ä½ ", "å†¯æ³ è¶Šä¸çæƒœç”°ç”œå¤©æ‰“é›·åŠˆ",
        "å°å®å®è¦é…å°åŒ…åŒ…", "æˆ‘è¦ç»™ä½ æ´—ä¸€è¾ˆå­è„š", "lvå’Œloveæˆ‘éƒ½è¦ç»™ä½ ",
        "ä½ æŠŠæˆ‘ç…§é¡¾çš„å¾ˆå¥½å®å®", "è°¢è°¢ä½ çš„å‡ºç°", "æˆ‘çˆ±ä½ ",
        "ä¼šæœ‰å«lpçš„é‚£ä¸€å¤©çš„", "å®å®æƒ…äººèŠ‚å¿«ä¹", "ä½ æ¯”æ‰€æœ‰å°çŒ«éƒ½å¯çˆ±",
        "ä»Šå¹´å¼ºåº¦ä¸€èˆ¬ï¼Œæ˜å¹´å†æ¥å†å‰"
    ];

    function createTextPositions(text) {
        const canvas = document.getElementById('textCanvas');
        const ctx = canvas.getContext('2d');
        // ç¨å¾®è°ƒå¤§ä¸€ç‚¹é»˜è®¤å­—å·
        const fontSize = text.length > 8 ? 75 : 110;
        const spread = text.length > 8 ? 24 : 18;

        canvas.width = 1024; canvas.height = 512;
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff'; ctx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);

        const data = ctx.getImageData(0,0,canvas.width,canvas.height).data;
        const points = [];
        for(let y=0; y<canvas.height; y+=4) {
            for(let x=0; x<canvas.width; x+=4) {
                if(data[(y*canvas.width+x)*4] > 128) {
                    // yè½´å‘ä¸Šåç§»ä¸€ç‚¹ï¼Œè®©æ–‡å­—å¤§æ¦‚åœ¨å±å¹•ä¸­ä¸Šæ–¹
                    points.push({ x: (x - canvas.width/2) / spread, y: -(y - canvas.height/2) / spread + 2, z: 0 });
                }
            }
        }
        return points;
    }

    // è·å– 3D ä¸–ç•Œåæ ‡çš„è¾…åŠ©å‡½æ•°
    function get3DPos(e) {
        const ev = e.touches ? e.touches[0] : e;
        // æ˜ å°„å±å¹•åæ ‡åˆ° 3D ç©ºé—´åæ ‡ç³» (å¤§çº¦ 44x34 çš„èŒƒå›´)
        const x = (ev.clientX / window.innerWidth) * 44 - 22;
        const y = -(ev.clientY / window.innerHeight) * 34 + 17;
        return { x, y };
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        // 1. é¢„ç”Ÿæˆå¿ƒå½¢ç‚¹
        let count = 0;
        while (count < PARTICLE_COUNT) {
            const x = (Math.random() - 0.5) * 3, y = (Math.random() - 0.5) * 3, z = (Math.random() - 0.5) * 3;
            const a = x * x + (9 / 4) * y * y + z * z - 1;
            if (a * a * a - x * x * z * z * z - (9 / 80) * y * y * z * z * z < 0) {
                heartPositions.push({ x: x*8.5, y: z*8.5+2, z: y*8.5 });
                particleAttributes.push({ phi: Math.random()*Math.PI*2, spd: 1+Math.random()*2 });
                count++;
            }
        }

        // 2. é¢„ç”Ÿæˆæ‰€æœ‰å¥å­çš„åæ ‡ç‚¹
        loveWords.forEach(word => {
            textOptionsPositions.push(createTextPositions(word));
        });

        // 3. åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
        const geo = new THREE.BufferGeometry();
        const posArr = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            posArr[i*3]=heartPositions[i].x; posArr[i*3+1]=heartPositions[i].y; posArr[i*3+2]=heartPositions[i].z;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        starPoints = new THREE.Points(geo, new THREE.PointsMaterial({
            color: 0xff69b4, size: 0.15, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        scene.add(starPoints);

        // 4. ç…§ç‰‡é¢„å¤‡
        const loader = new THREE.TextureLoader();
        for (let i = 1; i <= PHOTO_COUNT; i++) {
            photoRandoms.push({ phi: Math.random()*Math.PI*2, radius: 10+Math.random()*8, yR: (Math.random()-0.5)*15, zR: (Math.random()-0.5)*10, spd: 0.3+Math.random()*0.4 });
            loader.load(`pics/${i}.jpg`, (tex) => {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.3, 3.1), new THREE.MeshBasicMaterial({map: tex, transparent: true, opacity: 0, side: THREE.DoubleSide}));
                mesh.scale.set(0.01, 0.01, 0.01); scene.add(mesh); photoMeshes.push(mesh);
                if (++loadProgress >= PHOTO_COUNT) document.getElementById('start-btn').style.display = 'block';
            }, undefined, () => { if (++loadProgress >= PHOTO_COUNT) document.getElementById('start-btn').style.display = 'block'; });
        }

        // --- æ ¸å¿ƒäº¤äº’é€»è¾‘æ›´æ–° (æ”¯æŒæ‹–æ‹½) ---
        const container = document.getElementById('container');

        const start = (e) => {
            isTouching = true;
            currentTextIndex = Math.floor(Math.random() * loveWords.length);
            const pos = get3DPos(e);
            // è®°å½•èµ·å§‹ç‚¹
            dragStartX = pos.x; dragStartY = pos.y;
            // é‡ç½®åç§»é‡
            dragOffsetX = 0; dragOffsetY = 0;
            // æ›´æ–°ç…§ç‰‡ä¸­å¿ƒ
            tX = pos.x; tY = pos.y;
        };

        const move = (e) => {
            if(isTouching) {
                const pos = get3DPos(e);
                // è®¡ç®—æ‹–æ‹½çš„åç§»é‡
                dragOffsetX = pos.x - dragStartX;
                dragOffsetY = pos.y - dragStartY;
                // ç…§ç‰‡è·Ÿéšæ‰‹æŒ‡ä¸­å¿ƒ
                tX = pos.x; tY = pos.y;
            }
        };

        const end = () => { isTouching = false; };

        container.addEventListener('pointerdown', start);
        window.addEventListener('pointerup', end);
        container.addEventListener('pointermove', move);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = starPoints.geometry.attributes.position.array;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const attr = particleAttributes[i];
            let tx, ty, tz, damping;

            if (isTouching) {
                // æŒ‰ä½æ—¶ï¼šæ±‡èšæˆæ–‡å­— + åŠ ä¸Šæ‹–æ‹½åç§»é‡(dragOffset)
                const targetArr = textOptionsPositions[currentTextIndex];
                const target = targetArr[i % targetArr.length];
                // æ ¸å¿ƒï¼šç›®æ ‡ä½ç½® = åŸå§‹æ–‡å­—ä½ç½® + æ‹–æ‹½åç§» + å”¯ç¾æµ®åŠ¨
                tx = target.x + dragOffsetX + Math.sin(time * 2 + attr.phi) * 0.3;
                ty = target.y + dragOffsetY + Math.cos(time * 2 + attr.phi) * 0.3;
                tz = target.z + Math.sin(time * 1.5 + attr.phi) * 0.5;
                damping = 0.07;
            } else {
                // å¹³æ—¶ï¼šå¿ƒå½¢
                const target = heartPositions[i];
                tx = target.x + Math.sin(time * 2 + attr.phi) * 0.15;
                ty = target.y + Math.cos(time * 2 + attr.phi) * 0.15;
                tz = target.z;
                damping = 0.08;
            }
            positions[i3] += (tx - positions[i3]) * damping;
            positions[i3+1] += (ty - positions[i3+1]) * damping;
            positions[i3+2] += (tz - positions[i3+2]) * damping;
        }
        starPoints.geometry.attributes.position.needsUpdate = true;

        if (!isTouching) starPoints.rotation.y += 0.006;
        else starPoints.rotation.y += (0 - starPoints.rotation.y) * 0.05;

        // ç…§ç‰‡åŠ¨ç”»
        photoMeshes.forEach((mesh, i) => {
            const r = photoRandoms[i];
            if (isTouching) {
                const angle = time * r.spd + r.phi;
                // ç…§ç‰‡å›´ç»•å½“å‰æ‰‹æŒ‡ä½ç½®(tX, tY)æ—‹è½¬
                mesh.position.lerp(new THREE.Vector3(tX+Math.cos(angle)*r.radius, tY+Math.sin(angle)*r.radius+r.yR*0.2, r.zR), 0.05);
                mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.05);
                mesh.material.opacity += (1 - mesh.material.opacity) * 0.05;
                mesh.lookAt(camera.position);
            } else {
                mesh.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                mesh.scale.lerp(new THREE.Vector3(0.01, 0.01, 0.01), 0.1);
                mesh.material.opacity *= 0.8;
            }
        });
        renderer.render(scene, camera);
    }

    document.getElementById('start-btn').onclick = () => {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; document.getElementById('hint').style.opacity = '1'; }, 1000);
        document.getElementById('bgm').play();
    };
    init(); animate();
</script>
</body>
</html>